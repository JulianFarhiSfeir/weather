{"version":3,"file":"default-node_modules_angular_core_fesm2022_rxjs-interop_mjs.js","mappings":"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","sources":["./node_modules/rxjs/_esm2015/internal/ReplaySubject.js","./node_modules/rxjs/_esm2015/internal/operators/observeOn.js","./node_modules/rxjs/_esm2015/internal/scheduler/QueueAction.js","./node_modules/rxjs/_esm2015/internal/scheduler/QueueScheduler.js","./node_modules/rxjs/_esm2015/internal/scheduler/queue.js","./node_modules/@angular/core/fesm2022/rxjs-interop.mjs"],"sourcesContent":["import { Subject } from './Subject';\nimport { queue } from './scheduler/queue';\nimport { Subscription } from './Subscription';\nimport { ObserveOnSubscriber } from './operators/observeOn';\nimport { ObjectUnsubscribedError } from './util/ObjectUnsubscribedError';\nimport { SubjectSubscription } from './SubjectSubscription';\nexport class ReplaySubject extends Subject {\n    constructor(bufferSize = Number.POSITIVE_INFINITY, windowTime = Number.POSITIVE_INFINITY, scheduler) {\n        super();\n        this.scheduler = scheduler;\n        this._events = [];\n        this._infiniteTimeWindow = false;\n        this._bufferSize = bufferSize < 1 ? 1 : bufferSize;\n        this._windowTime = windowTime < 1 ? 1 : windowTime;\n        if (windowTime === Number.POSITIVE_INFINITY) {\n            this._infiniteTimeWindow = true;\n            this.next = this.nextInfiniteTimeWindow;\n        }\n        else {\n            this.next = this.nextTimeWindow;\n        }\n    }\n    nextInfiniteTimeWindow(value) {\n        const _events = this._events;\n        _events.push(value);\n        if (_events.length > this._bufferSize) {\n            _events.shift();\n        }\n        super.next(value);\n    }\n    nextTimeWindow(value) {\n        this._events.push(new ReplayEvent(this._getNow(), value));\n        this._trimBufferThenGetEvents();\n        super.next(value);\n    }\n    _subscribe(subscriber) {\n        const _infiniteTimeWindow = this._infiniteTimeWindow;\n        const _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents();\n        const scheduler = this.scheduler;\n        const len = _events.length;\n        let subscription;\n        if (this.closed) {\n            throw new ObjectUnsubscribedError();\n        }\n        else if (this.isStopped || this.hasError) {\n            subscription = Subscription.EMPTY;\n        }\n        else {\n            this.observers.push(subscriber);\n            subscription = new SubjectSubscription(this, subscriber);\n        }\n        if (scheduler) {\n            subscriber.add(subscriber = new ObserveOnSubscriber(subscriber, scheduler));\n        }\n        if (_infiniteTimeWindow) {\n            for (let i = 0; i < len && !subscriber.closed; i++) {\n                subscriber.next(_events[i]);\n            }\n        }\n        else {\n            for (let i = 0; i < len && !subscriber.closed; i++) {\n                subscriber.next(_events[i].value);\n            }\n        }\n        if (this.hasError) {\n            subscriber.error(this.thrownError);\n        }\n        else if (this.isStopped) {\n            subscriber.complete();\n        }\n        return subscription;\n    }\n    _getNow() {\n        return (this.scheduler || queue).now();\n    }\n    _trimBufferThenGetEvents() {\n        const now = this._getNow();\n        const _bufferSize = this._bufferSize;\n        const _windowTime = this._windowTime;\n        const _events = this._events;\n        const eventsCount = _events.length;\n        let spliceCount = 0;\n        while (spliceCount < eventsCount) {\n            if ((now - _events[spliceCount].time) < _windowTime) {\n                break;\n            }\n            spliceCount++;\n        }\n        if (eventsCount > _bufferSize) {\n            spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);\n        }\n        if (spliceCount > 0) {\n            _events.splice(0, spliceCount);\n        }\n        return _events;\n    }\n}\nclass ReplayEvent {\n    constructor(time, value) {\n        this.time = time;\n        this.value = value;\n    }\n}\n","import { Subscriber } from '../Subscriber';\nimport { Notification } from '../Notification';\nexport function observeOn(scheduler, delay = 0) {\n    return function observeOnOperatorFunction(source) {\n        return source.lift(new ObserveOnOperator(scheduler, delay));\n    };\n}\nexport class ObserveOnOperator {\n    constructor(scheduler, delay = 0) {\n        this.scheduler = scheduler;\n        this.delay = delay;\n    }\n    call(subscriber, source) {\n        return source.subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));\n    }\n}\nexport class ObserveOnSubscriber extends Subscriber {\n    constructor(destination, scheduler, delay = 0) {\n        super(destination);\n        this.scheduler = scheduler;\n        this.delay = delay;\n    }\n    static dispatch(arg) {\n        const { notification, destination } = arg;\n        notification.observe(destination);\n        this.unsubscribe();\n    }\n    scheduleMessage(notification) {\n        const destination = this.destination;\n        destination.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));\n    }\n    _next(value) {\n        this.scheduleMessage(Notification.createNext(value));\n    }\n    _error(err) {\n        this.scheduleMessage(Notification.createError(err));\n        this.unsubscribe();\n    }\n    _complete() {\n        this.scheduleMessage(Notification.createComplete());\n        this.unsubscribe();\n    }\n}\nexport class ObserveOnMessage {\n    constructor(notification, destination) {\n        this.notification = notification;\n        this.destination = destination;\n    }\n}\n","import { AsyncAction } from './AsyncAction';\nexport class QueueAction extends AsyncAction {\n    constructor(scheduler, work) {\n        super(scheduler, work);\n        this.scheduler = scheduler;\n        this.work = work;\n    }\n    schedule(state, delay = 0) {\n        if (delay > 0) {\n            return super.schedule(state, delay);\n        }\n        this.delay = delay;\n        this.state = state;\n        this.scheduler.flush(this);\n        return this;\n    }\n    execute(state, delay) {\n        return (delay > 0 || this.closed) ?\n            super.execute(state, delay) :\n            this._execute(state, delay);\n    }\n    requestAsyncId(scheduler, id, delay = 0) {\n        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {\n            return super.requestAsyncId(scheduler, id, delay);\n        }\n        return scheduler.flush(this);\n    }\n}\n","import { AsyncScheduler } from './AsyncScheduler';\nexport class QueueScheduler extends AsyncScheduler {\n}\n","import { QueueAction } from './QueueAction';\nimport { QueueScheduler } from './QueueScheduler';\nexport const queue = new QueueScheduler(QueueAction);\n","/**\n * @license Angular v16.2.5\n * (c) 2010-2022 Google LLC. https://angular.io/\n * License: MIT\n */\n\nimport { assertInInjectionContext, inject, DestroyRef, Injector, effect, untracked as untracked$1, signal as signal$1, computed as computed$1 } from '@angular/core';\nimport { Observable, ReplaySubject } from 'rxjs';\nimport { takeUntil } from 'rxjs/operators';\n\n/**\n * Operator which completes the Observable when the calling context (component, directive, service,\n * etc) is destroyed.\n *\n * @param destroyRef optionally, the `DestroyRef` representing the current context. This can be\n *     passed explicitly to use `takeUntilDestroyed` outside of an [injection\n * context](guide/dependency-injection-context). Otherwise, the current `DestroyRef` is injected.\n *\n * @developerPreview\n */\nfunction takeUntilDestroyed(destroyRef) {\n    if (!destroyRef) {\n        assertInInjectionContext(takeUntilDestroyed);\n        destroyRef = inject(DestroyRef);\n    }\n    const destroyed$ = new Observable(observer => {\n        const unregisterFn = destroyRef.onDestroy(observer.next.bind(observer));\n        return unregisterFn;\n    });\n    return (source) => {\n        return source.pipe(takeUntil(destroyed$));\n    };\n}\n\n/**\n * Exposes the value of an Angular `Signal` as an RxJS `Observable`.\n *\n * The signal's value will be propagated into the `Observable`'s subscribers using an `effect`.\n *\n * `toObservable` must be called in an injection context unless an injector is provided via options.\n *\n * @developerPreview\n */\nfunction toObservable(source, options) {\n    !options?.injector && assertInInjectionContext(toObservable);\n    const injector = options?.injector ?? inject(Injector);\n    const subject = new ReplaySubject(1);\n    const watcher = effect(() => {\n        let value;\n        try {\n            value = source();\n        }\n        catch (err) {\n            untracked$1(() => subject.error(err));\n            return;\n        }\n        untracked$1(() => subject.next(value));\n    }, { injector, manualCleanup: true });\n    injector.get(DestroyRef).onDestroy(() => {\n        watcher.destroy();\n        subject.complete();\n    });\n    return subject.asObservable();\n}\n\n/**\n * Base URL for the error details page.\n *\n * Keep this constant in sync across:\n *  - packages/compiler-cli/src/ngtsc/diagnostics/src/error_details_base_url.ts\n *  - packages/core/src/error_details_base_url.ts\n */\nconst ERROR_DETAILS_PAGE_BASE_URL = 'https://angular.io/errors';\n/**\n * URL for the XSS security documentation.\n */\nconst XSS_SECURITY_URL = 'https://g.co/ng/security#xss';\n\n/**\n * Class that represents a runtime error.\n * Formats and outputs the error message in a consistent way.\n *\n * Example:\n * ```\n *  throw new RuntimeError(\n *    RuntimeErrorCode.INJECTOR_ALREADY_DESTROYED,\n *    ngDevMode && 'Injector has already been destroyed.');\n * ```\n *\n * Note: the `message` argument contains a descriptive error message as a string in development\n * mode (when the `ngDevMode` is defined). In production mode (after tree-shaking pass), the\n * `message` argument becomes `false`, thus we account for it in the typings and the runtime\n * logic.\n */\nclass RuntimeError extends Error {\n    constructor(code, message) {\n        super(formatRuntimeError(code, message));\n        this.code = code;\n    }\n}\n/**\n * Called to format a runtime error.\n * See additional info on the `message` argument type in the `RuntimeError` class description.\n */\nfunction formatRuntimeError(code, message) {\n    // Error code might be a negative number, which is a special marker that instructs the logic to\n    // generate a link to the error details page on angular.io.\n    // We also prepend `0` to non-compile-time errors.\n    const fullCode = `NG0${Math.abs(code)}`;\n    let errorMessage = `${fullCode}${message ? ': ' + message : ''}`;\n    if (ngDevMode && code < 0) {\n        const addPeriodSeparator = !errorMessage.match(/[.,;!?\\n]$/);\n        const separator = addPeriodSeparator ? '.' : '';\n        errorMessage =\n            `${errorMessage}${separator} Find more at ${ERROR_DETAILS_PAGE_BASE_URL}/${fullCode}`;\n    }\n    return errorMessage;\n}\n\n/**\n * Symbol used to tell `Signal`s apart from other functions.\n *\n * This can be used to auto-unwrap signals in various cases, or to auto-wrap non-signal values.\n */\nconst SIGNAL = Symbol('SIGNAL');\n/**\n * Checks if the given `value` is a reactive `Signal`.\n *\n * @developerPreview\n */\nfunction isSignal(value) {\n    return typeof value === 'function' && value[SIGNAL] !== undefined;\n}\n/**\n * The default equality function used for `signal` and `computed`, which treats objects and arrays\n * as never equal, and all other primitive values using identity semantics.\n *\n * This allows signals to hold non-primitive values (arrays, objects, other collections) and still\n * propagate change notification upon explicit mutation without identity change.\n *\n * @developerPreview\n */\nfunction defaultEquals(a, b) {\n    // `Object.is` compares two values using identity semantics which is desired behavior for\n    // primitive values. If `Object.is` determines two values to be equal we need to make sure that\n    // those don't represent objects (we want to make sure that 2 objects are always considered\n    // \"unequal\"). The null check is needed for the special case of JavaScript reporting null values\n    // as objects (`typeof null === 'object'`).\n    return (a === null || typeof a !== 'object') && Object.is(a, b);\n}\n\nconst _global = globalThis;\n\nfunction ngDevModeResetPerfCounters() {\n    const locationString = typeof location !== 'undefined' ? location.toString() : '';\n    const newCounters = {\n        namedConstructors: locationString.indexOf('ngDevMode=namedConstructors') != -1,\n        firstCreatePass: 0,\n        tNode: 0,\n        tView: 0,\n        rendererCreateTextNode: 0,\n        rendererSetText: 0,\n        rendererCreateElement: 0,\n        rendererAddEventListener: 0,\n        rendererSetAttribute: 0,\n        rendererRemoveAttribute: 0,\n        rendererSetProperty: 0,\n        rendererSetClassName: 0,\n        rendererAddClass: 0,\n        rendererRemoveClass: 0,\n        rendererSetStyle: 0,\n        rendererRemoveStyle: 0,\n        rendererDestroy: 0,\n        rendererDestroyNode: 0,\n        rendererMoveNode: 0,\n        rendererRemoveNode: 0,\n        rendererAppendChild: 0,\n        rendererInsertBefore: 0,\n        rendererCreateComment: 0,\n        hydratedNodes: 0,\n        hydratedComponents: 0,\n        dehydratedViewsRemoved: 0,\n        dehydratedViewsCleanupRuns: 0,\n        componentsSkippedHydration: 0,\n    };\n    // Make sure to refer to ngDevMode as ['ngDevMode'] for closure.\n    const allowNgDevModeTrue = locationString.indexOf('ngDevMode=false') === -1;\n    _global['ngDevMode'] = allowNgDevModeTrue && newCounters;\n    return newCounters;\n}\n/**\n * This function checks to see if the `ngDevMode` has been set. If yes,\n * then we honor it, otherwise we default to dev mode with additional checks.\n *\n * The idea is that unless we are doing production build where we explicitly\n * set `ngDevMode == false` we should be helping the developer by providing\n * as much early warning and errors as possible.\n *\n * `ɵɵdefineComponent` is guaranteed to have been called before any component template functions\n * (and thus Ivy instructions), so a single initialization there is sufficient to ensure ngDevMode\n * is defined for the entire instruction set.\n *\n * When checking `ngDevMode` on toplevel, always init it before referencing it\n * (e.g. `((typeof ngDevMode === 'undefined' || ngDevMode) && initNgDevMode())`), otherwise you can\n *  get a `ReferenceError` like in https://github.com/angular/angular/issues/31595.\n *\n * Details on possible values for `ngDevMode` can be found on its docstring.\n *\n * NOTE:\n * - changes to the `ngDevMode` name must be synced with `compiler-cli/src/tooling.ts`.\n */\nfunction initNgDevMode() {\n    // The below checks are to ensure that calling `initNgDevMode` multiple times does not\n    // reset the counters.\n    // If the `ngDevMode` is not an object, then it means we have not created the perf counters\n    // yet.\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n        if (typeof ngDevMode !== 'object') {\n            ngDevModeResetPerfCounters();\n        }\n        return typeof ngDevMode !== 'undefined' && !!ngDevMode;\n    }\n    return false;\n}\n\n// Required as the signals library is in a separate package, so we need to explicitly ensure the\n/**\n * The currently active consumer `ReactiveNode`, if running code in a reactive context.\n *\n * Change this via `setActiveConsumer`.\n */\nlet activeConsumer = null;\nlet inNotificationPhase = false;\nfunction setActiveConsumer(consumer) {\n    const prev = activeConsumer;\n    activeConsumer = consumer;\n    return prev;\n}\nconst REACTIVE_NODE = {\n    version: 0,\n    dirty: false,\n    producerNode: undefined,\n    producerLastReadVersion: undefined,\n    producerIndexOfThis: undefined,\n    nextProducerIndex: 0,\n    liveConsumerNode: undefined,\n    liveConsumerIndexOfThis: undefined,\n    consumerAllowSignalWrites: false,\n    consumerIsAlwaysLive: false,\n    producerMustRecompute: () => false,\n    producerRecomputeValue: () => { },\n    consumerMarkedDirty: () => { },\n};\n/**\n * Called by implementations when a producer's signal is read.\n */\nfunction producerAccessed(node) {\n    if (inNotificationPhase) {\n        throw new Error(typeof ngDevMode !== 'undefined' && ngDevMode ?\n            `Assertion error: signal read during notification phase` :\n            '');\n    }\n    if (activeConsumer === null) {\n        // Accessed outside of a reactive context, so nothing to record.\n        return;\n    }\n    // This producer is the `idx`th dependency of `activeConsumer`.\n    const idx = activeConsumer.nextProducerIndex++;\n    assertConsumerNode(activeConsumer);\n    if (idx < activeConsumer.producerNode.length && activeConsumer.producerNode[idx] !== node) {\n        // There's been a change in producers since the last execution of `activeConsumer`.\n        // `activeConsumer.producerNode[idx]` holds a stale dependency which will be be removed and\n        // replaced with `this`.\n        //\n        // If `activeConsumer` isn't live, then this is a no-op, since we can replace the producer in\n        // `activeConsumer.producerNode` directly. However, if `activeConsumer` is live, then we need\n        // to remove it from the stale producer's `liveConsumer`s.\n        if (consumerIsLive(activeConsumer)) {\n            const staleProducer = activeConsumer.producerNode[idx];\n            producerRemoveLiveConsumerAtIndex(staleProducer, activeConsumer.producerIndexOfThis[idx]);\n            // At this point, the only record of `staleProducer` is the reference at\n            // `activeConsumer.producerNode[idx]` which will be overwritten below.\n        }\n    }\n    if (activeConsumer.producerNode[idx] !== node) {\n        // We're a new dependency of the consumer (at `idx`).\n        activeConsumer.producerNode[idx] = node;\n        // If the active consumer is live, then add it as a live consumer. If not, then use 0 as a\n        // placeholder value.\n        activeConsumer.producerIndexOfThis[idx] =\n            consumerIsLive(activeConsumer) ? producerAddLiveConsumer(node, activeConsumer, idx) : 0;\n    }\n    activeConsumer.producerLastReadVersion[idx] = node.version;\n}\n/**\n * Ensure this producer's `version` is up-to-date.\n */\nfunction producerUpdateValueVersion(node) {\n    if (consumerIsLive(node) && !node.dirty) {\n        // A live consumer will be marked dirty by producers, so a clean state means that its version\n        // is guaranteed to be up-to-date.\n        return;\n    }\n    if (!node.producerMustRecompute(node) && !consumerPollProducersForChange(node)) {\n        // None of our producers report a change since the last time they were read, so no\n        // recomputation of our value is necessary, and we can consider ourselves clean.\n        node.dirty = false;\n        return;\n    }\n    node.producerRecomputeValue(node);\n    // After recomputing the value, we're no longer dirty.\n    node.dirty = false;\n}\n/**\n * Propagate a dirty notification to live consumers of this producer.\n */\nfunction producerNotifyConsumers(node) {\n    if (node.liveConsumerNode === undefined) {\n        return;\n    }\n    // Prevent signal reads when we're updating the graph\n    const prev = inNotificationPhase;\n    inNotificationPhase = true;\n    try {\n        for (const consumer of node.liveConsumerNode) {\n            if (!consumer.dirty) {\n                consumerMarkDirty(consumer);\n            }\n        }\n    }\n    finally {\n        inNotificationPhase = prev;\n    }\n}\n/**\n * Whether this `ReactiveNode` in its producer capacity is currently allowed to initiate updates,\n * based on the current consumer context.\n */\nfunction producerUpdatesAllowed() {\n    return activeConsumer?.consumerAllowSignalWrites !== false;\n}\nfunction consumerMarkDirty(node) {\n    node.dirty = true;\n    producerNotifyConsumers(node);\n    node.consumerMarkedDirty?.(node);\n}\n/**\n * Prepare this consumer to run a computation in its reactive context.\n *\n * Must be called by subclasses which represent reactive computations, before those computations\n * begin.\n */\nfunction consumerBeforeComputation(node) {\n    node && (node.nextProducerIndex = 0);\n    return setActiveConsumer(node);\n}\n/**\n * Finalize this consumer's state after a reactive computation has run.\n *\n * Must be called by subclasses which represent reactive computations, after those computations\n * have finished.\n */\nfunction consumerAfterComputation(node, prevConsumer) {\n    setActiveConsumer(prevConsumer);\n    if (!node || node.producerNode === undefined || node.producerIndexOfThis === undefined ||\n        node.producerLastReadVersion === undefined) {\n        return;\n    }\n    if (consumerIsLive(node)) {\n        // For live consumers, we need to remove the producer -> consumer edge for any stale producers\n        // which weren't dependencies after the recomputation.\n        for (let i = node.nextProducerIndex; i < node.producerNode.length; i++) {\n            producerRemoveLiveConsumerAtIndex(node.producerNode[i], node.producerIndexOfThis[i]);\n        }\n    }\n    // Truncate the producer tracking arrays.\n    for (let i = node.nextProducerIndex; i < node.producerNode.length; i++) {\n        node.producerNode.pop();\n        node.producerLastReadVersion.pop();\n        node.producerIndexOfThis.pop();\n    }\n}\n/**\n * Determine whether this consumer has any dependencies which have changed since the last time\n * they were read.\n */\nfunction consumerPollProducersForChange(node) {\n    assertConsumerNode(node);\n    // Poll producers for change.\n    for (let i = 0; i < node.producerNode.length; i++) {\n        const producer = node.producerNode[i];\n        const seenVersion = node.producerLastReadVersion[i];\n        // First check the versions. A mismatch means that the producer's value is known to have\n        // changed since the last time we read it.\n        if (seenVersion !== producer.version) {\n            return true;\n        }\n        // The producer's version is the same as the last time we read it, but it might itself be\n        // stale. Force the producer to recompute its version (calculating a new value if necessary).\n        producerUpdateValueVersion(producer);\n        // Now when we do this check, `producer.version` is guaranteed to be up to date, so if the\n        // versions still match then it has not changed since the last time we read it.\n        if (seenVersion !== producer.version) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Disconnect this consumer from the graph.\n */\nfunction consumerDestroy(node) {\n    assertConsumerNode(node);\n    if (consumerIsLive(node)) {\n        // Drop all connections from the graph to this node.\n        for (let i = 0; i < node.producerNode.length; i++) {\n            producerRemoveLiveConsumerAtIndex(node.producerNode[i], node.producerIndexOfThis[i]);\n        }\n    }\n    // Truncate all the arrays to drop all connection from this node to the graph.\n    node.producerNode.length = node.producerLastReadVersion.length = node.producerIndexOfThis.length =\n        0;\n    if (node.liveConsumerNode) {\n        node.liveConsumerNode.length = node.liveConsumerIndexOfThis.length = 0;\n    }\n}\n/**\n * Add `consumer` as a live consumer of this node.\n *\n * Note that this operation is potentially transitive. If this node becomes live, then it becomes\n * a live consumer of all of its current producers.\n */\nfunction producerAddLiveConsumer(node, consumer, indexOfThis) {\n    assertProducerNode(node);\n    assertConsumerNode(node);\n    if (node.liveConsumerNode.length === 0) {\n        // When going from 0 to 1 live consumers, we become a live consumer to our producers.\n        for (let i = 0; i < node.producerNode.length; i++) {\n            node.producerIndexOfThis[i] = producerAddLiveConsumer(node.producerNode[i], node, i);\n        }\n    }\n    node.liveConsumerIndexOfThis.push(indexOfThis);\n    return node.liveConsumerNode.push(consumer) - 1;\n}\n/**\n * Remove the live consumer at `idx`.\n */\nfunction producerRemoveLiveConsumerAtIndex(node, idx) {\n    assertProducerNode(node);\n    assertConsumerNode(node);\n    if (node.liveConsumerNode.length === 1) {\n        // When removing the last live consumer, we will no longer be live. We need to remove\n        // ourselves from our producers' tracking (which may cause consumer-producers to lose\n        // liveness as well).\n        for (let i = 0; i < node.producerNode.length; i++) {\n            producerRemoveLiveConsumerAtIndex(node.producerNode[i], node.producerIndexOfThis[i]);\n        }\n    }\n    // Move the last value of `liveConsumers` into `idx`. Note that if there's only a single\n    // live consumer, this is a no-op.\n    const lastIdx = node.liveConsumerNode.length - 1;\n    node.liveConsumerNode[idx] = node.liveConsumerNode[lastIdx];\n    node.liveConsumerIndexOfThis[idx] = node.liveConsumerIndexOfThis[lastIdx];\n    // Truncate the array.\n    node.liveConsumerNode.length--;\n    node.liveConsumerIndexOfThis.length--;\n    // If the index is still valid, then we need to fix the index pointer from the producer to this\n    // consumer, and update it from `lastIdx` to `idx` (accounting for the move above).\n    if (idx < node.liveConsumerNode.length) {\n        const idxProducer = node.liveConsumerIndexOfThis[idx];\n        const consumer = node.liveConsumerNode[idx];\n        assertConsumerNode(consumer);\n        consumer.producerIndexOfThis[idxProducer] = idx;\n    }\n}\nfunction consumerIsLive(node) {\n    return node.consumerIsAlwaysLive || (node?.liveConsumerNode?.length ?? 0) > 0;\n}\nfunction assertConsumerNode(node) {\n    node.producerNode ??= [];\n    node.producerIndexOfThis ??= [];\n    node.producerLastReadVersion ??= [];\n}\nfunction assertProducerNode(node) {\n    node.liveConsumerNode ??= [];\n    node.liveConsumerIndexOfThis ??= [];\n}\n\n/**\n * Create a computed `Signal` which derives a reactive value from an expression.\n *\n * @developerPreview\n */\nfunction computed(computation, options) {\n    const node = Object.create(COMPUTED_NODE);\n    node.computation = computation;\n    options?.equal && (node.equal = options.equal);\n    const computed = () => {\n        // Check if the value needs updating before returning it.\n        producerUpdateValueVersion(node);\n        // Record that someone looked at this signal.\n        producerAccessed(node);\n        if (node.value === ERRORED) {\n            throw node.error;\n        }\n        return node.value;\n    };\n    computed[SIGNAL] = node;\n    return computed;\n}\n/**\n * A dedicated symbol used before a computed value has been calculated for the first time.\n * Explicitly typed as `any` so we can use it as signal's value.\n */\nconst UNSET = Symbol('UNSET');\n/**\n * A dedicated symbol used in place of a computed signal value to indicate that a given computation\n * is in progress. Used to detect cycles in computation chains.\n * Explicitly typed as `any` so we can use it as signal's value.\n */\nconst COMPUTING = Symbol('COMPUTING');\n/**\n * A dedicated symbol used in place of a computed signal value to indicate that a given computation\n * failed. The thrown error is cached until the computation gets dirty again.\n * Explicitly typed as `any` so we can use it as signal's value.\n */\nconst ERRORED = Symbol('ERRORED');\nconst COMPUTED_NODE = {\n    ...REACTIVE_NODE,\n    value: UNSET,\n    dirty: true,\n    error: null,\n    equal: defaultEquals,\n    producerMustRecompute(node) {\n        // Force a recomputation if there's no current value, or if the current value is in the process\n        // of being calculated (which should throw an error).\n        return node.value === UNSET || node.value === COMPUTING;\n    },\n    producerRecomputeValue(node) {\n        if (node.value === COMPUTING) {\n            // Our computation somehow led to a cyclic read of itself.\n            throw new Error('Detected cycle in computations.');\n        }\n        const oldValue = node.value;\n        node.value = COMPUTING;\n        const prevConsumer = consumerBeforeComputation(node);\n        let newValue;\n        try {\n            newValue = node.computation();\n        }\n        catch (err) {\n            newValue = ERRORED;\n            node.error = err;\n        }\n        finally {\n            consumerAfterComputation(node, prevConsumer);\n        }\n        if (oldValue !== UNSET && oldValue !== ERRORED && newValue !== ERRORED &&\n            node.equal(oldValue, newValue)) {\n            // No change to `valueVersion` - old and new values are\n            // semantically equivalent.\n            node.value = oldValue;\n            return;\n        }\n        node.value = newValue;\n        node.version++;\n    },\n};\n\nfunction defaultThrowError() {\n    throw new Error();\n}\nlet throwInvalidWriteToSignalErrorFn = defaultThrowError;\nfunction throwInvalidWriteToSignalError() {\n    throwInvalidWriteToSignalErrorFn();\n}\nfunction setThrowInvalidWriteToSignalError(fn) {\n    throwInvalidWriteToSignalErrorFn = fn;\n}\n\n/**\n * If set, called after `WritableSignal`s are updated.\n *\n * This hook can be used to achieve various effects, such as running effects synchronously as part\n * of setting a signal.\n */\nlet postSignalSetFn = null;\n/**\n * Create a `Signal` that can be set or updated directly.\n *\n * @developerPreview\n */\nfunction signal(initialValue, options) {\n    const node = Object.create(SIGNAL_NODE);\n    node.value = initialValue;\n    options?.equal && (node.equal = options.equal);\n    function signalFn() {\n        producerAccessed(node);\n        return node.value;\n    }\n    signalFn.set = signalSetFn;\n    signalFn.update = signalUpdateFn;\n    signalFn.mutate = signalMutateFn;\n    signalFn.asReadonly = signalAsReadonlyFn;\n    signalFn[SIGNAL] = node;\n    return signalFn;\n}\nfunction setPostSignalSetFn(fn) {\n    const prev = postSignalSetFn;\n    postSignalSetFn = fn;\n    return prev;\n}\nconst SIGNAL_NODE = {\n    ...REACTIVE_NODE,\n    equal: defaultEquals,\n    readonlyFn: undefined,\n};\nfunction signalValueChanged(node) {\n    node.version++;\n    producerNotifyConsumers(node);\n    postSignalSetFn?.();\n}\nfunction signalSetFn(newValue) {\n    const node = this[SIGNAL];\n    if (!producerUpdatesAllowed()) {\n        throwInvalidWriteToSignalError();\n    }\n    if (!node.equal(node.value, newValue)) {\n        node.value = newValue;\n        signalValueChanged(node);\n    }\n}\nfunction signalUpdateFn(updater) {\n    if (!producerUpdatesAllowed()) {\n        throwInvalidWriteToSignalError();\n    }\n    signalSetFn.call(this, updater(this[SIGNAL].value));\n}\nfunction signalMutateFn(mutator) {\n    const node = this[SIGNAL];\n    if (!producerUpdatesAllowed()) {\n        throwInvalidWriteToSignalError();\n    }\n    // Mutate bypasses equality checks as it's by definition changing the value.\n    mutator(node.value);\n    signalValueChanged(node);\n}\nfunction signalAsReadonlyFn() {\n    const node = this[SIGNAL];\n    if (node.readonlyFn === undefined) {\n        const readonlyFn = () => this();\n        readonlyFn[SIGNAL] = node;\n        node.readonlyFn = readonlyFn;\n    }\n    return node.readonlyFn;\n}\n\n/**\n * Execute an arbitrary function in a non-reactive (non-tracking) context. The executed function\n * can, optionally, return a value.\n *\n * @developerPreview\n */\nfunction untracked(nonReactiveReadsFn) {\n    const prevConsumer = setActiveConsumer(null);\n    // We are not trying to catch any particular errors here, just making sure that the consumers\n    // stack is restored in case of errors.\n    try {\n        return nonReactiveReadsFn();\n    }\n    finally {\n        setActiveConsumer(prevConsumer);\n    }\n}\n\nfunction watch(fn, schedule, allowSignalWrites) {\n    const node = Object.create(WATCH_NODE);\n    if (allowSignalWrites) {\n        node.consumerAllowSignalWrites = true;\n    }\n    node.fn = fn;\n    node.schedule = schedule;\n    const registerOnCleanup = (cleanupFn) => {\n        node.cleanupFn = cleanupFn;\n    };\n    const run = () => {\n        node.dirty = false;\n        if (node.hasRun && !consumerPollProducersForChange(node)) {\n            return;\n        }\n        node.hasRun = true;\n        const prevConsumer = consumerBeforeComputation(node);\n        try {\n            node.cleanupFn();\n            node.cleanupFn = NOOP_CLEANUP_FN;\n            node.fn(registerOnCleanup);\n        }\n        finally {\n            consumerAfterComputation(node, prevConsumer);\n        }\n    };\n    node.ref = {\n        notify: () => consumerMarkDirty(node),\n        run,\n        cleanup: () => node.cleanupFn(),\n    };\n    return node.ref;\n}\nconst NOOP_CLEANUP_FN = () => { };\nconst WATCH_NODE = {\n    ...REACTIVE_NODE,\n    consumerIsAlwaysLive: true,\n    consumerAllowSignalWrites: false,\n    consumerMarkedDirty: (node) => {\n        node.schedule(node.ref);\n    },\n    hasRun: false,\n    cleanupFn: NOOP_CLEANUP_FN,\n};\n\nfunction setAlternateWeakRefImpl(impl) {\n    // TODO: remove this function\n}\n\nfunction toSignal(source, options) {\n    const requiresCleanup = !options?.manualCleanup;\n    requiresCleanup && !options?.injector && assertInInjectionContext(toSignal);\n    const cleanupRef = requiresCleanup ? options?.injector?.get(DestroyRef) ?? inject(DestroyRef) : null;\n    // Note: T is the Observable value type, and U is the initial value type. They don't have to be\n    // the same - the returned signal gives values of type `T`.\n    let state;\n    if (options?.requireSync) {\n        // Initially the signal is in a `NoValue` state.\n        state = signal$1({ kind: 0 /* StateKind.NoValue */ });\n    }\n    else {\n        // If an initial value was passed, use it. Otherwise, use `undefined` as the initial value.\n        state = signal$1({ kind: 1 /* StateKind.Value */, value: options?.initialValue });\n    }\n    const sub = source.subscribe({\n        next: value => state.set({ kind: 1 /* StateKind.Value */, value }),\n        error: error => state.set({ kind: 2 /* StateKind.Error */, error }),\n        // Completion of the Observable is meaningless to the signal. Signals don't have a concept of\n        // \"complete\".\n    });\n    if (ngDevMode && options?.requireSync && untracked(state).kind === 0 /* StateKind.NoValue */) {\n        throw new RuntimeError(601 /* RuntimeErrorCode.REQUIRE_SYNC_WITHOUT_SYNC_EMIT */, '`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.');\n    }\n    // Unsubscribe when the current context is destroyed, if requested.\n    cleanupRef?.onDestroy(sub.unsubscribe.bind(sub));\n    // The actual returned signal is a `computed` of the `State` signal, which maps the various states\n    // to either values or errors.\n    return computed$1(() => {\n        const current = state();\n        switch (current.kind) {\n            case 1 /* StateKind.Value */:\n                return current.value;\n            case 2 /* StateKind.Error */:\n                throw current.error;\n            case 0 /* StateKind.NoValue */:\n                // This shouldn't really happen because the error is thrown on creation.\n                // TODO(alxhub): use a RuntimeError when we finalize the error semantics\n                throw new RuntimeError(601 /* RuntimeErrorCode.REQUIRE_SYNC_WITHOUT_SYNC_EMIT */, '`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.');\n        }\n    });\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { takeUntilDestroyed, toObservable, toSignal };\n"],"names":["Subject","queue","Subscription","ObserveOnSubscriber","ObjectUnsubscribedError","SubjectSubscription","ReplaySubject","constructor","bufferSize","Number","POSITIVE_INFINITY","windowTime","scheduler","_events","_infiniteTimeWindow","_bufferSize","_windowTime","next","nextInfiniteTimeWindow","nextTimeWindow","value","push","length","shift","ReplayEvent","_getNow","_trimBufferThenGetEvents","_subscribe","subscriber","len","subscription","closed","isStopped","hasError","EMPTY","observers","add","i","error","thrownError","complete","now","eventsCount","spliceCount","time","Math","max","splice","Subscriber","Notification","observeOn","delay","observeOnOperatorFunction","source","lift","ObserveOnOperator","call","subscribe","destination","dispatch","arg","notification","observe","unsubscribe","scheduleMessage","schedule","ObserveOnMessage","_next","createNext","_error","err","createError","_complete","createComplete","AsyncAction","QueueAction","work","state","flush","execute","_execute","requestAsyncId","id","AsyncScheduler","QueueScheduler","assertInInjectionContext","inject","DestroyRef","Injector","effect","untracked","untracked$1","signal","signal$1","computed","computed$1","Observable","takeUntil","takeUntilDestroyed","destroyRef","destroyed$","observer","unregisterFn","onDestroy","bind","pipe","toObservable","options","injector","subject","watcher","manualCleanup","get","destroy","asObservable","ERROR_DETAILS_PAGE_BASE_URL","XSS_SECURITY_URL","RuntimeError","Error","code","message","formatRuntimeError","fullCode","abs","errorMessage","ngDevMode","addPeriodSeparator","match","separator","SIGNAL","Symbol","isSignal","undefined","defaultEquals","a","b","Object","is","_global","globalThis","ngDevModeResetPerfCounters","locationString","location","toString","newCounters","namedConstructors","indexOf","firstCreatePass","tNode","tView","rendererCreateTextNode","rendererSetText","rendererCreateElement","rendererAddEventListener","rendererSetAttribute","rendererRemoveAttribute","rendererSetProperty","rendererSetClassName","rendererAddClass","rendererRemoveClass","rendererSetStyle","rendererRemoveStyle","rendererDestroy","rendererDestroyNode","rendererMoveNode","rendererRemoveNode","rendererAppendChild","rendererInsertBefore","rendererCreateComment","hydratedNodes","hydratedComponents","dehydratedViewsRemoved","dehydratedViewsCleanupRuns","componentsSkippedHydration","allowNgDevModeTrue","initNgDevMode","activeConsumer","inNotificationPhase","setActiveConsumer","consumer","prev","REACTIVE_NODE","version","dirty","producerNode","producerLastReadVersion","producerIndexOfThis","nextProducerIndex","liveConsumerNode","liveConsumerIndexOfThis","consumerAllowSignalWrites","consumerIsAlwaysLive","producerMustRecompute","producerRecomputeValue","consumerMarkedDirty","producerAccessed","node","idx","assertConsumerNode","consumerIsLive","staleProducer","producerRemoveLiveConsumerAtIndex","producerAddLiveConsumer","producerUpdateValueVersion","consumerPollProducersForChange","producerNotifyConsumers","consumerMarkDirty","producerUpdatesAllowed","consumerBeforeComputation","consumerAfterComputation","prevConsumer","pop","producer","seenVersion","consumerDestroy","indexOfThis","assertProducerNode","lastIdx","idxProducer","computation","create","COMPUTED_NODE","equal","ERRORED","UNSET","COMPUTING","oldValue","newValue","defaultThrowError","throwInvalidWriteToSignalErrorFn","throwInvalidWriteToSignalError","setThrowInvalidWriteToSignalError","fn","postSignalSetFn","initialValue","SIGNAL_NODE","signalFn","set","signalSetFn","update","signalUpdateFn","mutate","signalMutateFn","asReadonly","signalAsReadonlyFn","setPostSignalSetFn","readonlyFn","signalValueChanged","updater","mutator","nonReactiveReadsFn","watch","allowSignalWrites","WATCH_NODE","registerOnCleanup","cleanupFn","run","hasRun","NOOP_CLEANUP_FN","ref","notify","cleanup","setAlternateWeakRefImpl","impl","toSignal","requiresCleanup","cleanupRef","requireSync","kind","sub","current"],"sourceRoot":"webpack:///","x_google_ignoreList":[0,1,2,3,4,5]}